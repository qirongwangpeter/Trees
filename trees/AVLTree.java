package trees;
import support.trees.*;

public class AVLTree<E extends Comparable<E>> implements AVLT<E>{
    Node<E> root;
    int size;

    public int size(){
        return size;
    }

    public int height(Node<E> node){
        if( node == null){
            return -1;
        }
        return 1+Math.max(height(node.left),height(node.right));
    }
    public E get(E e){
        Node<E> n = find(e);
        if(n != null){
            return n.data;
        }else{
            return null;
        }
    }
    public boolean contains(E e){
        Node<E> n =find(e);
        return n != null;
    }
//----------------------------------------------------------------------------------------------------------------
    public Node<E> find(E e){
        return find(root,e);
    }
    private Node<E> find(Node<E> node, E e){
        if(node == null){// the first two said that only two cases:contain or not.
            return null;
        }
        if(e.equals(node.data)){
            return node;
        }
        if(e.compareTo(node.data) < 0){//these two bring the recursion to the correct half.
            return find(node.left, e);
        }else{
            return find(node.right,e);
        }
    }

    public E finddata(E e){
        return find(root, e).data;
    }
//----------------------------------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------------------------------
    public void add(E e){
        if(root == null){
            root = new Node<>(e);
            return;
        }
        add(root,e);
    }
    private void add(Node<E> node, E e){// will add the parent and the insersioncheck method later.
        if(e.equals(node.data)){// first, deal with the same data, just swap the same data.
            node.data = e;
        }else{//since there no more equals, check if it is greater or smaller.
            if(e.compareTo(node.data) < 0){
                if(node.left == null){//if the place we are going to add is null, we can add!
                    node.left = new Node<>(e);
                    node.left.parent = node;//set back the parent!
                    insertioncheck(node);//hints:we call .left or right so it won't just change the local variable node. It will change the tree!
                    size++;
                    return;
                }else{//if not, we have to go to the next place, the left.
                    add(node.left,e);
                }
            }else{
                if(node.right == null){
                    node.right = new Node<>(e);
                    node.right.parent = node;//set nack the parent!
                    insertioncheck(node);//cound start from the parent since the new node is sure to be balanced.
                    size++;
                    return;
                }else{
                    add(node.right,e);
                }
            }
        }
    }
//-----------------------------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------------------------
    public boolean isBST(Node<E> n){
        if(n == null){//not necessary, but quick to end! but for most of the time we need to run this if, which is a waste of time...
            return true;
        }
        return isBSTHelper(n,null,null);
    }
    private boolean isBSTHelper(Node<E> n, E min, E max){
        if(n == null){
            return true;
        }else{
            if(min != null && min.compareTo(n.data) >= 0){
                return false;
            }
            if(max != null && max.compareTo(n.data) <= 0){
                return false;
            }
            return isBSTHelper(n.left,min,n.data) && isBSTHelper(n.right,n.data,max);
        }
    }
//----------------------------------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------------------------------
    public boolean isAVL(Node<E> n){
        if(n == null){
            return true;
        }
        if(!isBST(n)){
            return false;
        }
        return isAVLHelper(n);
    }
    private boolean isAVLHelper(Node<E> n){
        if(n == null){
            return true;
        }
        if(Math.abs(height(n.right)-height(n.left)) > 1){//this is too time-consuming. I am thinking to store the height in each node as an extra data next time in the Node class.
            return false;
        }
        return isAVLHelper(n.left) && isAVLHelper(n.right);
    }
    /*
    the following is generated by Gemini for isAVL
    */
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    public boolean isAVLPro(Node<E> n){
        if (n == null) return true;
        if (!isBST(n)) return false; // 先确保是 BST
            return checkHeight(n) != -2; // -2 代表不平衡
    }

    /**
     * 返回节点的高度。如果发现不平衡，则返回 -2。
     */
    private int checkHeight(Node<E> n) {
        if (n == null) return -1; // 空节点高度 -1

        int leftH = checkHeight(n.left);
        if (leftH == -2) return -2; // 左边已经不平衡了，直接传递错误

        int rightH = checkHeight(n.right);
        if (rightH == -2) return -2; // 右边已经不平衡了

        // 检查当前层是否平衡
        if (Math.abs(leftH - rightH) > 1) {
            return -2; // 发现不平衡，标记错误
        }

        // 返回真实高度
        return 1 + Math.max(leftH, rightH);
    }
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//-----------------------------------------------------------------------------------------------------------------

    public void insertioncheck(Node<E> node){
        String path = "";
        //we will check each node from bottom all the way to the root one by one.
        while(true){
            if(!isAVL(node)){
                String currentPath = path.substring(0,2);//won't cause a problem because it won't reach here when the length is less than 2.
                if("LL".equals(currentPath)){
                    rotateright(node);
                }else if("RR".equals(currentPath)){
                    rotateleft(node);
                }else if("LR".equals(currentPath)){
                    rotateleft(node.left);//rotate the left child frist, and then the node itself.
                    rotateright(node);
                }else if("RL".equals(currentPath)){
                    rotateright(node.right);
                    rotateleft(node);
                }
                //add return here to avoid a crush. (suggested by Gemini AI.)
            }else{
                if(node != root){//collect all the path, insert.
                    if(node.parent.left == node){
                        path = "L" + path;
                    }else{
                        path = "R" + path;
                    }
                    node = node.parent;//easy to forget!
                }else{
                    return;//no need to break, return will automatically break!
                }
            }
        }
    }
    private void rotateleft(Node<E> node){
        if(node == null || node.right == null){
            return;//if there is only one or no element starting at the place you want to rotate, nothing will change.
        }
        Node<E> A, B, T1, T2, T3;
        A = node;
        B = A.right;
        T1 = A.left;
        T2 = B.left;
        T3 = B.right;
        
        if(A == root){
            root = B;
            B.parent = null;//put B in the right place first, also its parent.
        }else{
            if(A == A.parent.left){//left or right? we need if.
                A.parent.left = B;
                B.parent = A.parent;
            }else{
                A.parent.right = B;
                B.parent = A.parent;
            }
        }
        B.left = A;//dealing with A
        A.parent = B;// and its parent.

        A.right = T2;// dealing with B.left, which is already assigned by T2
        if(T2 != null){//dealing with T2's parent unless it is a null.
            T2.parent = A;
        }
    }

    private void rotateright(Node<E> node){
        if(node == null || node.left == null){
            return;
        }
        Node<E> A, B, T1, T2, T3;
        A = node;
        B = A.left;
        T1 = A.right;
        T3 = B.left;
        T2 = B.right;
        if(A == root){
            root = B;
            B.parent = null;
        }else{
            if(A.parent.left == A){
                A.parent.left = B;
                B.parent = A.parent;
            }else{
                A.parent.right = B;
                B.parent = A.parent;
            }
        }
        B.right = A;
        A.parent = B;

        A.left = T2;
        if(T2 != null){
            T2.parent = A;
        }
    }
//------------------------------------------------------------------------------------------------------------------------------
    public E remove(E e){
        Node<E> n = find(e);
        if(n == null){
            return null;
        }
        E data = n.data;
        size--;//easy to forget!
        if(n.right == null || n.left == null){
            
            Node<E> np = n.parent;
            splice(n);//splice before the check!Set the parent before the splice! won't affect n.child, so we start from the parent.
            deletioncheck(np);

            
            return data;
        }else{//has two children!
            Node<E> successor = n.right;
            while(successor.left != null){
                successor = successor.left;
            }
            n.data = successor.data;

            Node<E> np = successor.parent;
            splice(successor);
            deletioncheck(np);

            
            return data;
        }
        

    }
    private void deletioncheck(Node<E> node){
        Node<E> n = node;
        while(n != null){
            if(!(isAVL(n))){
                Node<E> p = n.parent;// we need to set the parent ahead of time because the rotation will change n's parent. Not nacessary, should avoid the overlaps.
                int leftheight = height(n.left);
                int rightheight = height(n.right);
                if(leftheight > rightheight){//L
                    int leftleftheight = height(n.left.left);
                    int leftrightheight = height(n.left.right);
                    if(leftleftheight >= leftrightheight){//LL
                        rotateright(n);
                    }else{//LR
                        rotateleft(n.left);
                        rotateright(n);
                    }
                }else{//R
                    int rightleftheight = height(n.right.left);
                    int rightrightheight = height(n.right.right);
                    if(rightrightheight >= rightleftheight){//RR
                        rotateleft(n);
                    }else{//RL
                        rotateright(n.right);
                        rotateleft(n);
                    }
                }
                n = p;//instead of n.parent as the reason above
            }else{
                n = n.parent;
            }
        }
    }
//------------------------------------------------------------------------------------------------------------------------------
    private void splice(Node<E> n){
        if(n == null){
            return;
        }
        if(n.right != null && n.left != null){
            throw new UnsupportedOperationException();
        }else{
            Node<E> p, c;// in splice we set the child first!
            if(n.left != null){
                c = n.left;
            }else{
                c = n.right;
            }

            if(n == root){//then we set parent here! Also do the splice.
                root = c;
                p = null;
            }else{
                p = n.parent;
                if(p.left == n){
                    p.left = c;
                }else{
                    p.right = c;
                }
            }
            if(c != null){ //c could be null here!
                c.parent = p;
            }
        } 
    }
}
